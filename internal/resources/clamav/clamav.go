package clamav

import (
	"fmt"
	"os"
	"os/exec"
	"strings"

	"ryanbyrne30/malware-scanner/internal/interfaces"
	"ryanbyrne30/malware-scanner/internal/utils"
)

type Clamav struct {
	Config string
}

func (c *Clamav) Scan(files []string) ([]*interfaces.MalwareScanResult, error) {
	f, err := c.filesToFile(files)
	if err != nil {
		return []*interfaces.MalwareScanResult{}, err
	}

	cmd := exec.Command("clamdscan", "-c", c.Config, "--fdpass", fmt.Sprintf("--file-list=%s", f.Name()))
	stdout, _ := cmd.Output()
	return c.parseScanOutput(string(stdout)), nil 
}

func (c *Clamav) parseScanOutput(output string) []*interfaces.MalwareScanResult {
	lines := strings.Split(output, "\n")
	result := []*interfaces.MalwareScanResult{}

	for _, line := range lines {
		if c.isScanOutputLineParsable(line) {
			result = append(result, c.parseScanOutputLine(line))
		}
	}

	return result
}

func (c *Clamav) isScanOutputLineParsable(line string) bool {
	segs := strings.Split(line, ":")
	if len(segs) < 2 {
		return false
	}

	path := segs[0]
	if !utils.FileExists(path) {
		return false
	}
	
	return true 
}

func (c *Clamav) parseScanOutputLine(line string) *interfaces.MalwareScanResult {
	segs := strings.SplitN(line, ":", 2)
	path := strings.TrimSpace(segs[0])
	status := strings.TrimSpace(segs[1])
	return &interfaces.MalwareScanResult{
		File: path,
		Ok: status == "OK",
		Status: status,
	} 
}

func (c *Clamav) filesToFile(files []string) (*os.File, error) {
	f, err := os.CreateTemp("", "scan-files.txt")

	if err != nil {
		return nil, err
	}

	content := strings.Join(files, "\n")

	_, err = f.Write([]byte(content))
	if err != nil {
		return nil, err
	}

	return f, nil
}